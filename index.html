<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <title>London Tube Station Heatmap</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=PT+Sans+Narrow:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --button-size: 22px;
            --button-font-size: 0.7em;
            --playback-icon-play-font-size: 0.9em; /* Adjusted for play icon */
            --playback-icon-pause-font-size: 1.2em; /* Keep for pause icon */
        }

        /* Custom CSS for map container to ensure it takes full height */
        #map {
            height: 80vh; /* Set a responsive height for the map */
            width: 100%;
            border-radius: 0.5rem; /* Apply rounded corners */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add a subtle shadow */
        }
        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
        /* Styles for the custom legend */
        .info.legend {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            line-height: 1.5em;
            font-size: 0.9em; /* Smaller font for legend */
        }
        .info.legend i {
            width: 18px;
            height: 12px;
            float: left;
            margin-right: 8px;
            opacity: 0.8;
            border-radius: 2px;
        }
        /* Styles for the combined controls box (Leaflet Control) */
        .leaflet-control.combined-controls-container {
            background: white;
            padding: 5px; /* Reduced padding for less height */
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            text-align: center;
            width: 300px; /* Fixed width for slider */
            /* Removed margin-bottom, margin-left, margin-right as it's now a Leaflet control */
        }
        .combined-controls-container .resolution-group {
            margin-bottom: 5px; /* Reduced margin */
            font-size: 1em; /* Increased font size for hourly/daily/weekly labels */
        }
        .combined-controls-container .time-slider-group {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 5px; /* Reduced margin */
        }
        .combined-controls-container input[type="range"] {
            flex-grow: 1;
            margin: 0 5px;
        }
        /* Play/Pause button styling - Adjusted size to match scroll buttons using CSS variables */
        .combined-controls-container .play-pause-button {
            background-color: #4CAF50; /* Green */
            border: none;
            color: white;
            padding: 0;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            margin-left: 8px;
            cursor: pointer;
            border-radius: 4px;
            width: var(--button-size);
            height: var(--button-size);
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        /* Specific font sizes for play and pause icons */
        .combined-controls-container .play-pause-button::before { /* pseudo-element for icon font-size */
            font-size: var(--playback-icon-play-font-size);
        }
        .combined-controls-container .play-pause-button.playing::before { /* pseudo-element for icon font-size when playing */
            font-size: var(--playback-icon-pause-font-size);
        }


        .combined-controls-container .play-pause-button:hover {
            background-color: #45a049;
        }
        /* Smaller scroll buttons using CSS variables */
        .scroll-button {
            background-color: #007bff; /* Blue */
            color: white;
            border: none;
            padding: 0;
            margin: 0 2px;
            cursor: pointer;
            border-radius: 3px;
            font-size: var(--button-font-size);
            width: var(--button-size);
            height: var(--button-size);
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        .scroll-button:hover {
            background-color: #0056b3;
        }
        /* Style for the new bottom-left timestamp control - Increased size, transparent white background, new font */
        .timestamp-display-control {
            font-size: 3.5em; /* Increased Larger font */
            color: #AAAAAA; /* Even lighter Grey lettering */
            font-family: 'PT Sans Narrow', sans-serif; /* New narrow font */
            text-shadow: 2px 2px 4px rgba(255,255,255,0.9); /* More pronounced white shadow for readability */
            background: transparent; /* Removed background color */
            padding: 0; /* Remove padding as background is gone */
            border-radius: 0; /* Remove border-radius as background is gone */
            white-space: nowrap; /* Prevent text from wrapping */
            bottom: 0px !important; /* Moved to very bottom */
            left: 0px !important; /* Moved to very left */
            line-height: 1; /* Adjust line height for closer packing */
        }
        /* Radio button styling */
        .resolution-group label {
            margin-right: 10px;
            font-size: 1em; /* Ensures text size is consistent with the new font-size for resolution-group */
        }
        .resolution-group input[type="radio"] {
            transform: scale(1.0); /* Smaller radio buttons */
            margin-right: 3px; /* Reduced margin */
        }
    </style>
</head>
<body class="bg-gray-100 p-4 sm:p-6 lg:p-8">
    <div class="container mx-auto p-4 bg-white rounded-lg shadow-xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-4 rounded-md p-2 bg-blue-100">
            London Tube Station Busyness Heatmap
        </h1>
        <p class="text-center text-gray-600 mb-6">
            This heatmap visualizes the relative busyness of London tube stations based on live footfall data compared to baseline, expressed as a percentage.
            Higher intensity (redder areas) indicates more crowding. Use the slider or play button to explore crowding at different time points.
        </p>

        <div id="map" class="mb-6"></div>

        <div class="text-center text-gray-500 text-sm">
            <p>Data Source: Processed data from your provided CSV files.</p>
            <p>Map tiles by <a href="https://www.openstreetmap.org/copyright" target="_blank" class="text-blue-500 hover:underline">OpenStreetMap</a> contributors.</p>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

    <script>
        // Global variables for current resolution and its timestamps
        let allProcessedData = {}; // This will hold the fetched data
        let currentResolution = 'hourly'; // Default resolution
        let timestamps = []; // Initialize as empty, will be populated after data fetch
        
        // Define the URL for your GeoJSON tube lines file
        const tubeLinesGeoJSONUrl = 'https://raw.githubusercontent.com/isi22/London-Crowds-Heatmap/main/data/TubeLines.geojson';

        // Define tube line colors in a reusable object
        const tubeLineColors = {
            'Central': '#E32017', 'Victoria': '#0098D4', 'Jubilee': '#A0A5A9',
            'Northern': '#000000', 'Piccadilly': '#003688', 'Bakerloo': '#B36305',
            'District': '#00782A', 'Hammersmith & City': '#F3A9BB', 'Metropolitan': '#9B0056',
            'Circle': '#FFD300', 'Waterloo & City': '#95CDBA', 'DLR': '#00A4A7',
            'Overground': '#EE7800', 'Elizabeth line': '#6950A1', 'Crossrail': '#7156A5'
        };

        let map;
        let heatmapLayer;
        let currentStationMarkers = [];

        let animationInterval;
        let isPlaying = false;
        let currentTimestampIndex = 0;
        const resolutionAnimationSpeeds = { // Define speeds per resolution
            hourly: 500,  // 0.5 seconds
            daily: 1000,  // 1 second
            weekly: 1000  // 1 second
        };
        let animationSpeed = resolutionAnimationSpeeds[currentResolution]; // Initial speed


        // Helper function to get ordinal suffix for a day number
        function getOrdinalSuffix(day) {
            if (day > 3 && day < 21) return 'th';
            switch (day % 10) {
                case 1: return 'st';
                case 2: return 'nd';
                case 3: return 'rd';
                default: return 'th';
            }
        }

        // Function to update heatmap and markers based on selected timestamp and resolution
        function updateMapData(index) {
            // Ensure index is within bounds for the current resolution's timestamps
            if (index < 0 || index >= timestamps.length) {
                console.warn("Timestamp index out of bounds for current resolution:", index);
                return;
            }
            currentTimestampIndex = parseInt(index);

            const selectedTimestampStr = timestamps[currentTimestampIndex];
            let formattedTimestamp = '';

            if (currentResolution === 'hourly') {
                const dateObj = new Date(selectedTimestampStr);
                // Round to nearest hour for consistent display
                dateObj.setMinutes(dateObj.getMinutes() >= 30 ? 60 : 0, 0, 0); 
                const weekday = dateObj.toLocaleDateString('en-US', { weekday: 'long' });
                const month = dateObj.toLocaleDateString('en-US', { month: 'long' });
                const day = dateObj.getDate();
                const year = dateObj.getFullYear();
                const hour = dateObj.getHours().toString().padStart(2, '0');
                formattedTimestamp = `${weekday}, ${month} ${day}<sup>${getOrdinalSuffix(day)}</sup> ${year}, ${hour}:00`;
            } else if (currentResolution === 'daily') {
                const dateObj = new Date(selectedTimestampStr);
                const month = dateObj.toLocaleDateString('en-US', { month: 'long' });
                const day = dateObj.getDate();
                const year = dateObj.getFullYear();
                formattedTimestamp = `${day}<sup>${getOrdinalSuffix(day)}</sup> ${month} ${year}`;
            } else if (currentResolution === 'weekly') {
                const weekStartDate = new Date(selectedTimestampStr);
                const weekEndDate = new Date(weekStartDate);
                weekEndDate.setDate(weekStartDate.getDate() + 6); // Add 6 days for end of week

                const startDay = weekStartDate.getDate();
                const startMonth = weekStartDate.toLocaleDateString('en-US', { month: 'long' });
                const startYear = weekStartDate.getFullYear();
                
                const endDay = weekEndDate.getDate();
                const endMonth = weekEndDate.toLocaleDateString('en-US', { month: 'long' });
                const endYear = weekEndDate.getFullYear();

                if (startMonth === endMonth && startYear === endYear) {
                    formattedTimestamp = `${startDay}<sup>${getOrdinalSuffix(startDay)}</sup> - ${endDay}<sup>${getOrdinalSuffix(endDay)}</sup> ${startMonth} ${startYear}`;
                } else if (startYear === endYear) {
                    formattedTimestamp = `${startDay}<sup>${getOrdinalSuffix(startDay)}</sup> ${startMonth} - ${endDay}<sup>${getOrdinalSuffix(endDay)}</sup> ${endMonth} ${startYear}`;
                } else {
                    formattedTimestamp = `${startDay}<sup>${getOrdinalSuffix(startDay)}</sup> ${startMonth} ${startYear} - ${endDay}<sup>${getOrdinalSuffix(endDay)}</sup> ${endMonth} ${endYear}`;
                }
            }

            document.getElementById('current-timestamp-display').innerHTML = formattedTimestamp; // Use innerHTML for superscript
            document.getElementById('time-slider').value = currentTimestampIndex;

            const currentStationData = allProcessedData[currentResolution][selectedTimestampStr];

            if (heatmapLayer) { map.removeLayer(heatmapLayer); }
            currentStationMarkers.forEach(marker => map.removeLayer(marker));
            currentStationMarkers = [];

            const cleanStationData = currentStationData.filter(entry =>
                Array.isArray(entry) && entry.length >= 4 &&
                typeof entry[0] === 'number' && !isNaN(entry[0]) &&
                typeof entry[1] === 'number' && !isNaN(entry[1])
            );

            const heatData = cleanStationData.map(station => {
                const lat = station[0]; const lon = station[1];
                let crowdingMetric = station[2];
                if (typeof crowdingMetric !== 'number' || isNaN(crowdingMetric)) { crowdingMetric = 0; }
                return [lat, lon, crowdingMetric];
            });

            const heatMax = 50; // Set heatMax to a fixed value of 50 (for 50%)

            heatmapLayer = L.heatLayer(heatData, {
                radius: 8, blur: 4, maxZoom: 0, max: heatMax,
                gradient: {
                    0.0: '#FFFFCC', 0.2: '#FFEDA0', 0.4: '#FED976',
                    0.6: '#FEB24C', 0.8: '#FD8D3C', 1.0: '#FC4E2A'
                }
            }).addTo(map);

            cleanStationData.forEach(station => {
                const lat = station[0]; const lon = station[1];
                const crowdingMetric = station[2]; const stationName = station[3];
                const marker = L.circleMarker([lat, lon], {
                    radius: 8, fillOpacity: 0, stroke: false, interactive: true
                })
                // Display crowding metric as an integer percentage in the popup
                .bindPopup(`<b>Station:</b> ${stationName}<br><b>Crowding Metric:</b> ${Math.round(crowdingMetric)}%`);
                marker.addTo(map);
                marker.bringToFront();
                currentStationMarkers.push(marker);
            });
        }

        // Function to toggle play/pause animation
        function toggleAnimation() {
            const playPauseButton = document.getElementById('play-pause-button');
            if (isPlaying) {
                clearInterval(animationInterval);
                playPauseButton.innerHTML = '&#9658;'; // Play icon (solid triangle)
                playPauseButton.classList.remove('playing'); // Remove playing class
            } else {
                if (currentTimestampIndex >= timestamps.length - 1) { currentTimestampIndex = 0; }
                updateMapData(currentTimestampIndex);
                // Clear any existing interval before setting a new one
                clearInterval(animationInterval); 
                animationInterval = setInterval(() => {
                    currentTimestampIndex = (currentTimestampIndex + 1) % timestamps.length;
                    updateMapData(currentTimestampIndex);
                }, animationSpeed); // Use dynamic animationSpeed
                playPauseButton.innerHTML = '&#9209;'; // Pause icon (double vertical bar)
                playPauseButton.classList.add('playing'); // Add playing class
            }
            isPlaying = !isPlaying;
        }

        // Function to scroll time by a given direction (+1 for right, -1 for left)
        function scrollTime(direction) {
            if (isPlaying) { toggleAnimation(); } // Pause animation if scrolling manually
            let newIndex = currentTimestampIndex + direction;
            if (newIndex < 0) {
                newIndex = 0; // Don't go below min
            } else if (newIndex >= timestamps.length) {
                newIndex = timestamps.length - 1; // Don't go above max
            }
            updateMapData(newIndex);
        }

        // Function to handle resolution change
        function changeResolution(newResolution) {
            if (isPlaying) { toggleAnimation(); } // Pause if playing
            currentResolution = newResolution;
            timestamps = Object.keys(allProcessedData[currentResolution]).sort();
            currentTimestampIndex = 0; // Reset slider to beginning
            
            // Update slider max value and animation speed
            const timeSlider = document.getElementById('time-slider');
            timeSlider.max = timestamps.length > 0 ? timestamps.length - 1 : 0;
            timeSlider.value = 0; // Reset slider position
            animationSpeed = resolutionAnimationSpeeds[currentResolution]; // Update animation speed

            updateMapData(0); // Update map with new resolution data
            console.log("Resolution changed to:", currentResolution);
        }


        window.onload = function() {
            map = L.map('map').setView([51.505, -0.09], 11);

            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
            }).addTo(map);

            map.createPane('tubeLinesPane');
            map.getPane('tubeLinesPane').style.zIndex = 350;

            fetch(tubeLinesGeoJSONUrl)
                .then(response => {
                    if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }
                    return response.json();
                })
                .then(geojsonData => {
                    L.geoJson(geojsonData, {
                        pane: 'tubeLinesPane',
                        style: function(feature) {
                            const lineColor = tubeLineColors[feature.properties.Name] || '#888888';
                            return {color: lineColor, weight: 2};
                        }
                    }).addTo(map);
                })
                .catch(error => console.error('Error loading tube lines GeoJSON:', error));

            const legend = L.control({position: 'bottomright'});
            legend.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'info legend');
                let labels = '<div style="font-size: 1.1em; font-weight: bold; margin-bottom: 5px;">Tube Lines</div>'; // Increased font size and added margin
                for (const lineName in tubeLineColors) {
                    labels += '<i style="background:' + tubeLineColors[lineName] + '"></i> ' + lineName + '<br>';
                }
                div.innerHTML = labels;
                return div;
            };
            legend.addTo(map);

            // Combined Controls Box (Leaflet Control)
            const combinedControls = L.control({position: 'topright'});
            combinedControls.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'combined-controls-container');
                div.innerHTML = `
                    <div class="resolution-group">
                        <label class="inline-flex items-center">
                            <input type="radio" name="resolution" value="hourly" checked class="form-radio text-blue-600">
                            <span class="ml-1 text-gray-700">Hourly</span>
                        </label>
                        <label class="inline-flex items-center ml-4">
                            <input type="radio" name="resolution" value="daily" class="form-radio text-blue-600">
                            <span class="ml-1 text-gray-700">Daily</span>
                        </label>
                        <label class="inline-flex items-center ml-4">
                            <input type="radio" name="resolution" value="weekly" class="form-radio text-blue-600">
                            <span class="ml-1 text-gray-700">Weekly</span>
                        </label>
                    </div>
                    <div class="time-slider-group">
                        <button id="scroll-left-button" class="scroll-button"> &lt; </button>
                        <input type="range" id="time-slider" min="0" max="${timestamps.length > 0 ? timestamps.length - 1 : 0}" value="0">
                        <button id="scroll-right-button" class="scroll-button"> &gt; </button>
                        <button id="play-pause-button" class="play-pause-button">&#9658;</button> </div>
                `;
                L.DomEvent.disableClickPropagation(div);
                L.DomEvent.disableScrollPropagation(div);
                return div;
            };
            combinedControls.addTo(map);


            // Timestamp Display Control (bottom-left)
            const timestampDisplayControl = L.control({position: 'bottomleft'});
            timestampDisplayControl.onAdd = function (map) {
                const div = L.DomUtil.create('div', 'timestamp-display-control');
                div.setAttribute('id', 'current-timestamp-display');
                div.innerHTML = 'Loading data...';
                L.DomEvent.disableClickPropagation(div);
                return div;
            };
            timestampDisplayControl.addTo(map);

            // Fetch the JSON data with cache busting
            // Appends current timestamp to force browser to re-fetch the JSON
            const jsonUrl = 'data/live_crowding_for_heatmap.json?' + new Date().getTime(); 
            fetch(jsonUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    Object.assign(allProcessedData, data); // Populate allProcessedData
                    console.log("All processed data by resolution:", allProcessedData);

                    // Initialize timestamps and slider based on fetched data
                    currentResolution = 'hourly'; // Default resolution
                    if (allProcessedData[currentResolution]) {
                        timestamps = Object.keys(allProcessedData[currentResolution]).sort();
                    } else {
                        timestamps = []; // No data for default resolution
                    }
                    currentTimestampIndex = 0;

                    const timeSlider = document.getElementById('time-slider');
                    timeSlider.max = timestamps.length > 0 ? timestamps.length - 1 : 0;
                    timeSlider.value = 0;

                    // Now initialize map with the first timestamp's data
                    if (timestamps.length > 0) {
                        updateMapData(0);
                    } else {
                        console.warn("No timestamp data available for current resolution.");
                    }

                    // Attach event listeners for the combined controls
                    document.getElementById('time-slider').addEventListener('input', function() {
                        if (isPlaying) { toggleAnimation(); }
                        updateMapData(this.value);
                    });
                    document.getElementById('play-pause-button').addEventListener('click', toggleAnimation);
                    document.getElementById('scroll-left-button').addEventListener('click', () => scrollTime(-1));
                    document.getElementById('scroll-right-button').addEventListener('click', () => scrollTime(1));
                    
                    // Attach event listeners for resolution radio buttons
                    document.querySelectorAll('input[name="resolution"]').forEach(radio => {
                        radio.addEventListener('change', function() {
                            changeResolution(this.value);
                        });
                    });

                })
                .catch(error => {
                    console.error('Error loading heatmap data JSON:', error);
                    // Fallback to empty map or show error message
                    if (timestamps.length === 0) {
                        map.setView([51.505, -0.09], 11); // Set default view if no data
                    }
                });
            
            map.on('resize', () => { map.invalidateSize(); }); // Ensure map resizes correctly
        };
    </script>
</body>
</html>